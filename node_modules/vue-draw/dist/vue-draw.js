import { getCurrentScope as J, onScopeDispose as Q, unref as Z, computed as b, watch as j, ref as D, getCurrentInstance as ee, onMounted as Y, nextTick as ne, defineComponent as te, useCssVars as re, toRefs as oe, watchEffect as ae, openBlock as ue, createElementBlock as se } from "vue";
function z(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(n, a) {
    var u = e.get(n);
    u ? u.push(a) : e.set(n, [a]);
  }, off: function(n, a) {
    var u = e.get(n);
    u && (a ? u.splice(u.indexOf(a) >>> 0, 1) : e.set(n, []));
  }, emit: function(n, a) {
    var u = e.get(n);
    u && u.slice().map(function(t) {
      t(a);
    }), (u = e.get("*")) && u.slice().map(function(t) {
      t(n, a);
    });
  } };
}
function A() {
  function e(t) {
    if (t instanceof MouseEvent)
      return n(t);
    if (t instanceof TouchEvent)
      return a(t);
    throw new Error("Invalid event type");
  }
  function n(t) {
    if (!(t.target instanceof HTMLElement))
      return { x: t == null ? void 0 : t.pageX, y: t == null ? void 0 : t.pageY };
    const { left: r, top: s } = t.target.getBoundingClientRect();
    return { x: (t == null ? void 0 : t.pageX) - r, y: (t == null ? void 0 : t.pageY) - s };
  }
  function a(t) {
    const r = t.touches[0];
    if (!(t.target instanceof HTMLElement))
      return { x: r == null ? void 0 : r.pageX, y: r == null ? void 0 : r.pageY };
    const { left: s, top: f } = t.target.getBoundingClientRect();
    return { x: (r == null ? void 0 : r.pageX) - s, y: (r == null ? void 0 : r.pageY) - f };
  }
  function u(t, r) {
    return [t.x, t.y, r.thickness, r.color, r.lineCap, r.erase];
  }
  return { getCursorCoords: e, getMouseCoords: n, getTouchCoords: a, createDrawingPoint: u };
}
function ie(e) {
  return J() ? (Q(e), !0) : !1;
}
function ce(e) {
  return typeof e == "function" ? e() : Z(e);
}
const le = typeof window < "u" && typeof document < "u";
function q(e) {
  var n;
  const a = ce(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
}
const ve = le ? window : void 0;
function fe() {
  const e = D(!1);
  return ee() && Y(() => {
    e.value = !0;
  }), e;
}
function de(e) {
  const n = fe();
  return b(() => (n.value, !!e()));
}
function pe(e, n, a = {}) {
  const { window: u = ve, ...t } = a;
  let r;
  const s = de(() => u && "ResizeObserver" in u), f = () => {
    r && (r.disconnect(), r = void 0);
  }, l = b(
    () => Array.isArray(e) ? e.map((g) => q(g)) : [q(e)]
  ), C = j(
    l,
    (g) => {
      if (f(), s.value && u) {
        r = new ResizeObserver(n);
        for (const d of g)
          d && r.observe(d, t);
      }
    },
    { immediate: !0, flush: "post", deep: !0 }
  ), p = () => {
    f(), C();
  };
  return ie(p), {
    isSupported: s,
    stop: p
  };
}
const ge = 0;
function X(e) {
  return e instanceof TouchEvent ? !0 : e.button === ge;
}
const we = () => window.devicePixelRatio || 1, Ce = () => "ontouchstart" in window, { getCursorCoords: me } = A(), he = "#ffffff", T = {
  thickness: 5,
  color: "#000000",
  lineCap: "round",
  erase: !1
};
function Ee() {
  const e = D(null), n = D(null), { on: a, off: u, emit: t } = z();
  Y(() => {
    if (!e.value)
      throw new Error("Canvas ref is null");
    r(), pe(e.value.parentElement, (o) => {
      const i = o[0], { width: c, height: E } = i.contentRect;
      L({ width: c, height: E }), ne(s);
    });
  });
  function r(o) {
    var c;
    const i = (o == null ? void 0 : o.getContext("2d")) || ((c = e.value) == null ? void 0 : c.getContext("2d"));
    i && (n.value = i);
  }
  function s() {
    if (f(), Ce())
      return p();
    l();
  }
  function f() {
    C(), g();
  }
  function l() {
    e.value && (e.value.addEventListener("mousedown", d), e.value.addEventListener("mouseup", w), e.value.addEventListener("mouseout", m), e.value.addEventListener("mousemove", h));
  }
  function C() {
    e.value && (e.value.removeEventListener("mousedown", d), e.value.removeEventListener("mouseup", w), e.value.removeEventListener("mouseout", m), e.value.removeEventListener("mousemove", h));
  }
  function p() {
    e.value && (e.value.addEventListener("touchstart", d, {
      passive: !0
    }), e.value.addEventListener("touchend", w, {
      passive: !0
    }), e.value.addEventListener("touchcancel", m, {
      passive: !0
    }), e.value.addEventListener("touchmove", h, {
      passive: !0
    }));
  }
  function g() {
    e.value && (e.value.removeEventListener("touchstart", d), e.value.removeEventListener("touchend", w), e.value.removeEventListener("touchcancel", m), e.value.removeEventListener("touchmove", h));
  }
  function d(o) {
    S(X(o), "cursor:start", o);
  }
  function w(o) {
    S(X(o), "cursor:stop", o);
  }
  function m(o) {
    v("cursor:cancel", o);
  }
  function h(o) {
    v("cursor:move", o);
  }
  function _(o) {
    if (!n.value)
      return;
    const i = o[0], [c, E] = i;
    n.value.beginPath(), n.value.moveTo(c, E);
    for (let O = 1; O < o.length; O++) {
      const N = o[O], [P, M, W, F, $] = N;
      n.value.lineWidth = W || T.thickness, n.value.strokeStyle = F || T.color, n.value.lineCap = $ || T.lineCap;
      const B = o[O + 1];
      if (!B)
        break;
      const [H, K] = B, V = (P + H) / 2, G = (M + K) / 2;
      n.value.quadraticCurveTo(P, M, V, G);
    }
    const k = o[o.length - 1], [R, U] = k;
    n.value.lineTo(R, U), n.value.stroke();
  }
  function y(o) {
    n.value && (x(), o.forEach((i) => {
      _(i);
    }));
  }
  function x() {
    !e.value || !n.value || n.value.clearRect(0, 0, e.value.width, e.value.height);
  }
  function L({ width: o, height: i }) {
    if (!e.value)
      return;
    const c = we();
    e.value.width = o * c, e.value.height = i * c, e.value.style.width = `${o}px`, e.value.style.height = `${i}px`, t("resize", { width: o, height: i }), n.value && n.value.setTransform(c, 0, 0, c, 0, 0);
  }
  function v(o, i) {
    t(o, me(i));
  }
  function S(o, i, c) {
    o && v(i, c);
  }
  function I(o = "image/png", i = 1) {
    return new Promise((c, E) => {
      var k;
      if (!e.value || !n.value)
        return E("Canvas ref is null");
      n.value.globalCompositeOperation = "destination-over", n.value.fillStyle = he, n.value.fillRect(0, 0, e.value.width, e.value.height), n.value.globalCompositeOperation = "source-over", (k = e.value) == null || k.toBlob(
        (R) => {
          if (!R)
            return E("Blob is null");
          c(R);
        },
        o,
        i
      );
    });
  }
  return {
    canvasRef: e,
    ctxRef: n,
    DrawingCanvasStroke: _,
    DrawingCanvas: y,
    clearCanvas: x,
    resizeCanvas: L,
    renderCanvas: I,
    on: a,
    off: u
  };
}
function De() {
  const e = D(!1), n = D(null), a = D([]);
  function u() {
    e.value = !0;
  }
  function t() {
    e.value = !1, s(), f();
  }
  function r(l) {
    n.value || (n.value = [l]), n.value.push(l);
  }
  function s() {
    n.value && a.value.push(n.value);
  }
  function f() {
    n.value = null;
  }
  return {
    isDrawing: e,
    currentStroke: n,
    drawing: a,
    startDrawingState: u,
    stopDrawingState: t,
    addDrawingPoint: r
  };
}
function _e() {
  const { canvasRef: e, DrawingCanvasStroke: n, DrawingCanvas: a, renderCanvas: u, clearCanvas: t, on: r } = Ee(), { isDrawing: s, currentStroke: f, drawing: l, startDrawingState: C, stopDrawingState: p, addDrawingPoint: g } = De(), { createDrawingPoint: d } = A();
  let w = {
    thickness: 5,
    color: "#000000",
    lineCap: "round",
    erase: !1
  };
  const { on: m, emit: h } = z();
  r("cursor:start", (v) => {
    s.value || (C(), y(v));
  }), r("cursor:stop", () => {
    s.value && (p(), a(l.value));
  }), r("cursor:move", (v) => {
    s.value && y(v);
  }), r("cursor:cancel", () => {
    s.value && p();
  }), r("resize", () => a(l.value));
  function _(v) {
    s.value && (g(v), f.value && (n(f.value), h("drawing", { point: v, drawing: l.value })));
  }
  function y(v) {
    if (!s.value)
      return;
    const S = d(v, w);
    _(S);
  }
  function x(v) {
    w = { ...w, ...v };
  }
  function L() {
    l.value = [], t();
  }
  return {
    canvasRef: e,
    isDrawing: s,
    drawing: l,
    setOptions: x,
    renderCanvas: u,
    resetCanvas: L,
    on: m
  };
}
const ye = /* @__PURE__ */ te({
  __name: "DrawingCanvas",
  props: {
    thickness: { type: Number, required: !1, default: 3 },
    background: { type: String, required: !1, default: "white" },
    color: { type: String, required: !1, default: "black" },
    colorName: { type: String, required: !1 },
    lineCap: { type: null, required: !1, default: "round" },
    erase: { type: Boolean, required: !1, default: !1 }
  },
  setup(e, { expose: n }) {
    const a = e;
    re((d) => ({
      "80c87c34-canvasBackgroundColor": g.value
    }));
    const { thickness: u, background: t, color: r, erase: s } = oe(a), { canvasRef: f, setOptions: l, renderCanvas: C, resetCanvas: p } = _e();
    ae(() => {
      l({
        thickness: u.value,
        color: s.value ? "white" : r.value,
        lineCap: "round",
        erase: s.value
      });
    }), n({
      renderCanvas: C,
      resetCanvas: p
    });
    const g = b(() => t.value);
    return (d, w) => (ue(), se(
      "canvas",
      {
        ref_key: "canvasRef",
        ref: f,
        class: "canvas"
      },
      null,
      512
      /* NEED_PATCH */
    ));
  }
});
const xe = (e, n) => {
  const a = e.__vccOpts || e;
  for (const [u, t] of n)
    a[u] = t;
  return a;
}, Se = /* @__PURE__ */ xe(ye, [["__scopeId", "data-v-80c87c34"], ["__file", "/home/daniel/Proyectos/vue-draw/src/components/DrawingCanvas.vue"]]);
export {
  Se as DrawingCanvas
};
